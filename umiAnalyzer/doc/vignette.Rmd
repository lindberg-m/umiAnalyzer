---
title: "umiAnalyzer vignette"
author: "Stefan Filges"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{umiAnalyzer vignette}
  %\usepackage[utf8]{inputenc}
---

```{r, echo = FALSE}
  knitr::opts_chunk$set(collapse = TRUE, 
                        comment = "#>",
                        fig.width=9, 
                        fig.height=6)
```

# Introduction

umiAnalyzer provides tools for analyzing umierrorcorrect output.

## Using the umiVisualiser shiny app

The shiny app requires the shiny, shinyFiles, tidyverse and DT packages and can
be run using the following command:

```{r runApp, eval=FALSE}
library(umiAnalyzer)

runUmiVisualiser()
```


## How to make your own umiExperiment object

Define a variable containing the path to the directory with all the umierrorcorrect 
output folders belonging to your experiment. umiAnalyzer comes with raw test data 
generated with umierrorcorrect that you can import if you don't have any of your own.

Call the createUmiExperiment to create your umiExperiment object.

The umiExperiment object always maintains your raw data, however you can create as many filters as you
like, which will be saved as separate objects to access. You can filter the consensus table of
umiExperiment object with filterUmiObject. The only mandatory arguments are the object to be filtered
and a user defined name. You can use that name to retrieve a filtered table using getFilter. 

```{r example1, eval=TRUE}
library(umiAnalyzer)

main <- system.file("extdata", package = "umiAnalyzer")

samples <- list.dirs(path = main, full.names = FALSE, recursive = FALSE)

simsen <- createUmiExperiment(experimentName = "simsen",
                              mainDir = main,
                              sampleNames = samples)

reads <- parseBamFiles(mainDir = main, sampleNames = samples, consDepth = 10)

plotFamilyHistogram(reads)
```

createUmiExperiment has an optional flag importBam, which is set to FALSE by default. 
If this is set to TRUE it will automatically call parseBamFiles and store the
read data in the 'simsen' object which can then be passed directly to plotFamilyHistogram,
without having to run parseBamFiles again. Note that for large experiments, 
especially if consDepth is set lower than 10, the size of the experiment object
may become too large.

Next we generate Quality Control plots and filter the umiExperiment object to
select for consensus 3 reads.

```{r example1continued, eval=TRUE}
simsen <- generateQCplots(simsen, do.plot = TRUE, group.by = "assay")

simsen <- filterUmiobject(
  object = simsen, name = "myfilter", minDepth = 3,
  minCoverage = 100, minFreq = 0, minCount = 0
)

myfilter <- getFilter(object = simsen, name = "myfilter")
myfilter
```

Next we generate plots for the amplicons and samples in the umiExperiment object.

If generateAmpliconPlots is called and the number of amplicons and samples is too
large to plot all of them individually in a single plot the data is shown in
summarised form. The user can specify amplicons and or samples optionally to
plot only the selection.

```{r ampliconPlots, eval=TRUE}
simsen <- generateAmpliconPlots(object = simsen, filter.name = "myfilter", do.plot = TRUE)

simsen <- generateAmpliconPlots(object = simsen, 
                                filter.name = "myfilter", 
                                do.plot = TRUE, 
                                amplicons = c("PIK3CA_123", "PIK3CA_234"), 
                                samples = "VAF-1-5ng-1-10x")
```

```{r replicates, eval=TRUE}
metaData <- system.file("extdata", "metadata.txt", package = "umiAnalyzer")
simsen <- importDesign(object = simsen, file = metaData)

simsen <- mergeTechnicalReplicates(object = simsen, filter.name = "myfilter")
simsen@merged.data

viz_Merged_data(simsen)
```

## Calling variants

umiAnalyzer comes with a build-in umiExperiment object to explore, which was generated using the code 
above, so it can be used without creating the it first if so desired.

In order to call variants using the umiAnalyzer variant caller simply load the package and test data
and use the callVariants function. You can then filter the resulting consensus data (cons.data) within
the object, e.g. for significant variants.

```{r example2, eval=FALSE}
data <- simsen
data <- callVariants(data)

data <- filterVariants(object = data, p.adjust = 0.2, minDepth = 5)
```

## Importing experimental designs and statistics
### Experimental design
umiAnalyzer supports adding meta data to a UMIsample or UMIexperiment object, such as experimental 
design matrices or clinical parameters. This is done using the importDesign function and requires a 
simple formatted table supplied by the user as a tab separated file. It is important that the order 
of the samples in the meta data file is the same as when building the UMIexperiment object.

```{r design, eval=FALSE}
data <- simsen
data <- callVariants(data)

metaData <- system.file("extdata", "metadata.txt", package = "umiAnalyzer")

data <- importDesign(object = data, file = metaData)
```

### Working with meta data

It is also possible to add meta data to an object and to retrieve metadata if needed. The design 
matrix loaded with importDesign can be retrieved as follows:

```{r getmetadata, eval=FALSE}
design <- getMetaData(object = data, attributeName = "design")

design
```

Similarly, any kind of meta data can be added and retrieved from an object using addMetaData:

```{r addmetadata, eval=FALSE}
comment <- "fix this"
data <- addMetaData(object = data, attributeName = "my-comment", attributeValue = comment)

myattribute <- getMetaData(object = data, attributeName = "my-comment")
myattribute
```




